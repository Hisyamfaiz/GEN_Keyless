C51 COMPILER V9.60.0.0   MAIN                                                              06/02/2020 16:44:09 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\build\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\main.c OPTIMIZE(8,SPEED) REGFILE(.\build\enhanced_shockburst_ptx_n
                    -rf24le1.ORC) BROWSE NOINTPROMOTE MODDP2 INCDIR(..\..\..\..\..\..\hal\nrf24le1;..\..\..\..\..\..\hal\nrf24l01p;..\..\..\.
                    -.\..\..\hal;..\..\..\..\..\..\compiler\c51;..\..\..\..\..\..\compiler\common) DEFINE(MCU_NRF24LE1) DEBUG OBJECTEXTEND PR
                    -INT(.\lst\main.lst) TABS(2) OBJECT(.\build\main.obj)

line level    source

   1          /*
   2          * An nRF24LE1 REGISTER RETENTION TIMER ON example application
   3          */
   4          
   5          // ======================================= Include header
   6          #include <Nordic\reg24le1.h>
   7          #include "hal_nrf.h"
   8          #include "hal_clk.h"
   9          #include "hal_rtc.h"
  10          #include "hal_delay.h"
  11          #include "hal_wdog.h"
  12          #include "hal_aes.h"
  13          #include "hal_rng.h"
  14          #include "hal_flash.h"
  15          #include <stdint.h>
  16          #include <stdbool.h>
  17          #include <string.h>
  18          
  19          // ======================================= Type definition
  20          #define TRANSISTOR            P10
  21          #define LED_1                 P11
  22          #define LED_2                 P13
  23          #define BTN_ALARM             P03
  24          #define BTN_SEAT              P01
  25          
  26          #define VADDR_VCU_ID          HAL_DATA_NV_BASE_ADDRESS
  27          #define VADDR_AES_KEY         (VADDR_VCU_ID + sizeof(uint32_t))
  28          
  29          #define DATA_LENGTH           16
  30          #define ADDR_LENGTH           5
  31          #define DATA_PAIR_LENGTH     (DATA_LENGTH + ADDR_LENGTH)
  32          
  33          typedef enum {
  34            KLESS_CMD_PING  = 0,
  35            KLESS_CMD_ALARM = 1,
  36            KLESS_CMD_SEAT  = 2
  37          } KLESS_CMD;
  38          
  39          // ======================================= Global variable
  40          static bool volatile radio_busy, received;
  41          static uint8_t tx_address[ADDR_LENGTH] = {0x00, 0x00, 0x00, 0x00, 0xCD};
  42          static uint8_t rx_address[ADDR_LENGTH] = {0x00, 0x00, 0x00, 0x00, 0xAB};
  43          static uint8_t xdata payload[DATA_PAIR_LENGTH];
  44          static uint8_t xdata payload_enc[DATA_LENGTH];
  45          static uint32_t idata AES_Key[4];
  46          static const uint8_t idata commands[3][8] = {
  47            { 0x5e, 0x6c, 0xa7, 0x74, 0xfd, 0xe3, 0xdf, 0xbc },
  48            { 0xf7, 0xda, 0x4a, 0x4f, 0x65, 0x2d, 0x6e, 0xf0 },
  49            { 0xff, 0xa6, 0xe6, 0x5a, 0x84, 0x82, 0x66, 0x4f }
  50          };
  51          
  52          // ======================================= Function prototype 
C51 COMPILER V9.60.0.0   MAIN                                                              06/02/2020 16:44:09 PAGE 2   

  53          void pin_init(void);
  54          void rtc_init(void);
  55          void clock_and_irq_init(void);
  56          void nrf_init(void);
  57          void sleep_mode(void);
  58          void make_random_number(uint8_t *p);
  59          void make_command(KLESS_CMD *cmd, hal_nrf_output_power_t *pwr);
  60          void make_payload(uint8_t *payload, uint8_t cmd);
  61          void send_payload(uint8_t *payload, uint8_t pwr);
  62          void set_pairing_mode(void);
  63          void receive_pairing(void);
  64          void update_configuration(uint8_t *success);
  65          
  66          // ======================================= Main function 
  67          void main(void){
  68   1        // local variable
  69   1        uint8_t vcu_id[4];
  70   1        uint8_t pairing_success;
  71   1        KLESS_CMD command;
  72   1        hal_nrf_output_power_t power;
  73   1        
  74   1        // Initialise GPIO
  75   1        pin_init();
  76   1        // Initialise RTC
  77   1        rtc_init();
  78   1        // Initialise clock & irq
  79   1        clock_and_irq_init();
  80   1        
  81   1        // Load Flash
  82   1        hal_flash_bytes_read(VADDR_VCU_ID, vcu_id, sizeof(uint32_t));
  83   1        hal_flash_bytes_read(VADDR_AES_KEY, (uint8_t*)AES_Key, DATA_LENGTH);
  84   1        
  85   1        // Apply address
  86   1        memcpy(tx_address, vcu_id, sizeof(uint32_t));
  87   1        memcpy(rx_address, vcu_id, sizeof(uint32_t));
  88   1        
  89   1        // Initialise RF module
  90   1        nrf_init();
  91   1        // Initialise AES
  92   1        hal_aes_setup(0, ECB, (uint8_t*)AES_Key, NULL);
  93   1        // Initialise watchdog
  94   1        hal_wdog_init(0x0300);
  95   1      
  96   1        while(1)  {           
  97   2          if(BTN_ALARM && BTN_SEAT){
  98   3            // Pairing Mode
  99   3            pairing_success = 0;
 100   3            // handle bounce effect
 101   3            delay_ms(100);
 102   3            
 103   3            // Set to pairing configuration
 104   3            set_pairing_mode();
 105   3            
 106   3            // Receive mode
 107   3            receive_pairing();
 108   3            
 109   3            // Check Payload
 110   3            update_configuration(&pairing_success);
 111   3              
 112   3            // indicator result
 113   3            if(pairing_success){
 114   4              LED_1 = 0;
C51 COMPILER V9.60.0.0   MAIN                                                              06/02/2020 16:44:09 PAGE 3   

 115   4              LED_2 = 0;
 116   4            } else {
 117   4              LED_1 = 1;
 118   4              LED_2 = 1;
 119   4            }
 120   3              
 121   3            // Wait until button released
 122   3            while((BTN_ALARM && BTN_SEAT)){
 123   4              hal_wdog_restart();
 124   4              delay_ms(50);
 125   4            }
 126   3            delay_ms(100);
 127   3            
 128   3          } else {
 129   3            // Normal Mode
 130   3            // Generate Random Number
 131   3            make_random_number(payload);
 132   3            // Generate Command
 133   3            make_command(&command, &power);
 134   3            // Insert command to payload with random position
 135   3            make_payload(payload, command);
 136   3            // Encrypt payload
 137   3            hal_aes_crypt(payload_enc, payload);
 138   3            // Send the payload
 139   3            send_payload(payload_enc, power);
 140   3            
 141   3            // indicator
 142   3            LED_1 = !LED_1;
 143   3            LED_2 = !LED_2;
 144   3          }
 145   2      
 146   2          // reset wdog
 147   2          hal_wdog_restart(); 
 148   2          
 149   2          // Enter sleep mode
 150   2          sleep_mode();
 151   2        };
 152   1      }
 153          
 154          // ======================================= Function declaration
 155          void update_configuration(uint8_t *success){
 156   1        if(received && (payload[DATA_PAIR_LENGTH - 1] == 0xAB)) {
 157   2          // Apply new aes key
 158   2          memcpy(AES_Key, payload, DATA_LENGTH);
 159   2          // Apply new address
 160   2          memcpy(tx_address, &payload[DATA_LENGTH], sizeof(uint32_t));
 161   2          memcpy(rx_address, &payload[DATA_LENGTH], sizeof(uint32_t));
 162   2          
 163   2          // Save to flash
 164   2          hal_flash_page_erase(HAL_DATA_NV_FLASH_PN1);
 165   2          hal_flash_bytes_write(VADDR_VCU_ID, &payload[DATA_LENGTH], sizeof(uint32_t));
 166   2          hal_flash_bytes_write(VADDR_AES_KEY, payload, DATA_LENGTH);
 167   2          
 168   2          // Update to new configuration
 169   2          hal_aes_setup(0, ECB, (uint8_t*)AES_Key, NULL);
 170   2          //setting Tx address
 171   2          hal_nrf_set_address(HAL_NRF_TX, tx_address);
 172   2          //setting Rx address for pipe0
 173   2          hal_nrf_set_address(HAL_NRF_PIPE0, rx_address);
 174   2          
 175   2          *success = 1;
 176   2        } 
C51 COMPILER V9.60.0.0   MAIN                                                              06/02/2020 16:44:09 PAGE 4   

 177   1      }
 178          
 179          void receive_pairing(void){
 180   1        // Power up radio
 181   1        hal_nrf_set_power_mode(HAL_NRF_PWR_UP);
 182   1        // Configure radio as primary receiver 
 183   1        hal_nrf_set_operation_mode(HAL_NRF_PRX); 
 184   1        
 185   1        // Enable receiver
 186   1        CE_HIGH();
 187   1        received = false;
 188   1        while (!received && (BTN_ALARM && BTN_SEAT)){
 189   2          // Indicator
 190   2          LED_1 = !LED_1;
 191   2          LED_2 = !LED_1;
 192   2      
 193   2          hal_wdog_restart();
 194   2          delay_ms(250);
 195   2        }
 196   1        CE_LOW();
 197   1        
 198   1        // Power off radio  
 199   1        hal_nrf_set_power_mode(HAL_NRF_PWR_DOWN);
 200   1        //setting payload width back
 201   1        hal_nrf_set_rx_payload_width(HAL_NRF_PIPE0, DATA_LENGTH); 
 202   1      }
 203          
 204          void set_pairing_mode(void) {
 205   1        // Set paring address
 206   1        memset(tx_address, 0x00, sizeof(uint32_t));
 207   1        memset(rx_address, 0x00, sizeof(uint32_t));
 208   1        
 209   1        //setting Tx address
 210   1        hal_nrf_set_address(HAL_NRF_TX, tx_address);
 211   1        //setting Rx address for pipe0
 212   1        hal_nrf_set_address(HAL_NRF_PIPE0,rx_address);
 213   1        //setting payload width
 214   1        hal_nrf_set_rx_payload_width(HAL_NRF_PIPE0, DATA_PAIR_LENGTH);
 215   1      }
 216          
 217          void send_payload(uint8_t *payload, uint8_t pwr){
 218   1        // Write payload to radio TX FIFO
 219   1        hal_nrf_write_tx_payload(payload, DATA_LENGTH);
 220   1        // Setting power output
 221   1        hal_nrf_set_output_power(pwr);
 222   1        // Set transistor based on Command
 223   1        TRANSISTOR = (pwr != HAL_NRF_0DBM);
 224   1        // Power up radio
 225   1        hal_nrf_set_power_mode(HAL_NRF_PWR_UP);
 226   1        // Configure radio as primary receiver (PTX)
 227   1        hal_nrf_set_operation_mode(HAL_NRF_PTX);
 228   1        
 229   1        // Start transmission
 230   1        CE_HIGH();
 231   1        radio_busy = true;
 232   1        while (radio_busy){}
 233   1        CE_LOW();
 234   1          
 235   1        // Power off radio  
 236   1        hal_nrf_set_power_mode(HAL_NRF_PWR_DOWN);
 237   1        // Set transistor to Open
 238   1        TRANSISTOR = 1; 
C51 COMPILER V9.60.0.0   MAIN                                                              06/02/2020 16:44:09 PAGE 5   

 239   1      }
 240          
 241          void make_payload(uint8_t *payload, uint8_t cmd){ 
 242   1        memcpy(payload, &commands[cmd], 8);
 243   1      }
 244          
 245          void make_command(KLESS_CMD *cmd, hal_nrf_output_power_t *pwr){
 246   1        *cmd = KLESS_CMD_PING;
 247   1        *pwr = HAL_NRF_18DBM;
 248   1        
 249   1        // Check buttons
 250   1        if(BTN_ALARM || BTN_SEAT){
 251   2          // handle bounce effect
 252   2          delay_ms(10);
 253   2          
 254   2          // handle each buttons
 255   2          if(BTN_SEAT)  {
 256   3            *cmd = KLESS_CMD_SEAT;
 257   3          } else if(BTN_ALARM)  {
 258   3            *cmd = KLESS_CMD_ALARM;
 259   3            *pwr = HAL_NRF_0DBM;
 260   3          }   
 261   2        }
 262   1      }
 263          
 264          void make_random_number(uint8_t *p){
 265   1        uint8_t index;
 266   1        
 267   1        // start
 268   1        hal_rng_power_up(1);
 269   1        for(index=0; index<DATA_LENGTH; index++){
 270   2          while(!hal_rng_data_ready()){};
 271   2          *(p++) = hal_rng_read();
 272   2        }
 273   1        hal_rng_power_up(0);
 274   1      }
 275          
 276          void pin_init(void){
 277   1        char i;
 278   1        
 279   1        // Disconnect unused GPIOs to avoid them floating in sleep
 280   1        for (i = 0; i < 8; i++){
 281   2            P0CON = 0x70 + i;
 282   2            P1CON = 0x70 + i;
 283   2        } 
 284   1        P0DIR = 0x0B; 
 285   1        P1DIR = 0x00;
 286   1      
 287   1        P1CON = 0x00 + 3; // Set P1.3 as output again
 288   1        P1CON = 0x00 + 0; // Set P1.1 as output again
 289   1        P0CON = 0x10 + 1; // Set P0.1 as input again
 290   1        P0CON = 0x10 + 3; // Set P0.3 as input again
 291   1          
 292   1        P0 = 0x00;
 293   1        P1 = 0x00;
 294   1        WUOPC0 = 0x0B;  //set pin P0.3 & P0.1 as wake-up pin
 295   1        OPMCON = 0x00;  //latch open and wake-up pin active high
 296   1        
 297   1        // Set default 
 298   1        TRANSISTOR = 1;
 299   1        LED_1 = 0;
 300   1        LED_2 = 0;
C51 COMPILER V9.60.0.0   MAIN                                                              06/02/2020 16:44:09 PAGE 6   

 301   1      }
 302          
 303          void nrf_init(void){
 304   1        // Setting datarate
 305   1        hal_nrf_set_datarate(HAL_NRF_250KBPS);
 306   1        //setting crc
 307   1        hal_nrf_set_crc_mode(HAL_NRF_CRC_8BIT);
 308   1        //setting address
 309   1        hal_nrf_set_address_width(HAL_NRF_AW_5BYTES);
 310   1        //setting auto retransmitt
 311   1        hal_nrf_set_auto_retr(0x0F,0x0F);
 312   1        //settinf RF channel
 313   1        hal_nrf_set_rf_channel(110);
 314   1        //setting Tx address
 315   1        hal_nrf_set_address(HAL_NRF_TX, tx_address);
 316   1        //setting payload width
 317   1        hal_nrf_set_rx_payload_width(HAL_NRF_PIPE0, DATA_LENGTH);
 318   1        //open pipe
 319   1        hal_nrf_open_pipe(HAL_NRF_PIPE0, 1);
 320   1        //setting Rx address for pipe0
 321   1        hal_nrf_set_address(HAL_NRF_PIPE0, rx_address);
 322   1        //setting interupt mode
 323   1        hal_nrf_set_irq_mode(HAL_NRF_MAX_RT,1);
 324   1        hal_nrf_set_irq_mode(HAL_NRF_TX_DS,1);
 325   1        hal_nrf_set_irq_mode(HAL_NRF_RX_DR,1);
 326   1        //disable ack
 327   1        hal_nrf_enable_ack_payload(1);
 328   1        //clear interupt flag
 329   1        hal_nrf_clear_irq_flag(HAL_NRF_MAX_RT);
 330   1        hal_nrf_clear_irq_flag(HAL_NRF_TX_DS);
 331   1        hal_nrf_clear_irq_flag(HAL_NRF_RX_DR);
 332   1      }
 333          
 334          void rtc_init(void){
 335   1        hal_rtc_start(false);
 336   1        hal_clklf_set_source(HAL_CLKLF_RCOSC32K);
 337   1        hal_rtc_set_compare_mode(HAL_RTC_COMPARE_MODE_0);
 338   1        hal_rtc_set_compare_value(0xFFFF);
 339   1        hal_rtc_start(true);
 340   1      
 341   1        // Wait for the 32kHz to startup (change phase)
 342   1        while((CLKLFCTRL&0x80)==0x80);
 343   1        while((CLKLFCTRL&0x80)!=0x80);
 344   1        
 345   1        // Setting wake-up from TICK and IRQ
 346   1        IEN1 = 0x20|0x08; 
 347   1      }
 348          
 349          void clock_and_irq_init(void){
 350   1        // Wait until 16 MHz crystal oscillator is running
 351   1        #ifdef MCU_NRF24LE1
 352   1        while(hal_clk_get_16m_source() != HAL_CLK_XOSC16M){}
 353   1        #endif
 354   1        // Enable the radio clock
 355   1        RFCKEN = 1U;
 356   1        // Enable RF irq
 357   1        RF = 1U;
 358   1        // Enable global irq
 359   1        EA = 1U;
 360   1      }
 361          
 362          void sleep_mode(void){
C51 COMPILER V9.60.0.0   MAIN                                                              06/02/2020 16:44:09 PAGE 7   

 363   1        // Register retention mode
 364   1        PWRDWN = 0x04;
 365   1        // Standby mode (wait for irq)
 366   1        PWRDWN = 0x07;
 367   1        // Clear PWRDWN
 368   1        PWRDWN = 0x00;
 369   1        // Exit sleep mode
 370   1      }
 371          
 372          // ======================================= Interrupt Service Routine
 373          // RTC wakeup by tick
 374          void wakeup_tick() interrupt INTERRUPT_TICK {
 375   1        // LED_2 = !LED_2; 
 376   1      }
 377          
 378          // RTC wakeup by button
 379          void wakeup_irq() interrupt INTERRUPT_WUOPIRQ {
 380   1        // LED_1 = !LED_1;
 381   1      }
 382          
 383          
 384          // Radio irq
 385          NRF_ISR() {
 386   1        uint8_t irq_flags;
 387   1      
 388   1        // Read and clear IRQ flags from radio
 389   1        irq_flags = hal_nrf_get_clear_irq_flags();
 390   1       
 391   1        switch(irq_flags)
 392   1        {
 393   2          // Transmission success
 394   2          case (1 << (uint8_t)HAL_NRF_TX_DS):
 395   2            radio_busy = false;
 396   2            // Data has been sent
 397   2            break;
 398   2          
 399   2          // Transmission failed (maximum re-transmits)
 400   2          case (1 << (uint8_t)HAL_NRF_MAX_RT):
 401   2            // When a MAX_RT interrupt occurs the TX payload will not be removed from the TX FIFO.
 402   2            // If the packet is to be discarded this must be done manually by flushing the TX FIFO.
 403   2            // Alternatively, CE_PULSE() can be called re-starting transmission of the payload.
 404   2            // (Will only be possible after the radio irq flags are cleared)
 405   2            hal_nrf_flush_tx();
 406   2            radio_busy = false;
 407   2            break;
 408   2          
 409   2          // Received success
 410   2          case (1 << (uint8_t)HAL_NRF_RX_DR):
 411   2            // Read payload
 412   2            while(!hal_nrf_rx_fifo_empty()){
 413   3              hal_nrf_read_rx_payload(payload);
 414   3            }
 415   2            received = true;
 416   2            break;
 417   2            
 418   2          default:
 419   2            break;
 420   2        }
 421   1        
 422   1      }
 423          /** @} */
 424          
C51 COMPILER V9.60.0.0   MAIN                                                              06/02/2020 16:44:09 PAGE 8   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1126    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     37    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12      23
   IDATA SIZE       =     40    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
