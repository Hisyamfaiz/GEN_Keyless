C51 COMPILER V9.60.0.0   MAIN                                                              01/13/2021 10:50:29 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\build\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) REGFILE(.\build\enhanced_shockburst_ptx_nrf24le
                    -1.ORC) BROWSE NOINTPROMOTE MODDP2 INCDIR(..\hal\nrf24le1;..\hal\nrf24l01p;..\hal;..\compiler\c51;..\compiler\common) DEF
                    -INE(MCU_NRF24LE1) DEBUG OBJECTEXTEND PRINT(.\lst\main.lst) TABS(2) OBJECT(.\build\main.obj)

line level    source

   1          /*
   2          * An nRF24LE1 REGISTER RETENTION TIMER ON example application
   3          * Master
   4          */
   5          
   6          // ======================================= Include header
   7          #include <Nordic\reg24le1.h>
   8          #include "hal_nrf.h"
   9          #include "hal_clk.h"
  10          #include "hal_rtc.h"
  11          #include "hal_delay.h"
  12          #include "hal_wdog.h"
  13          #include "hal_aes.h"
  14          #include "hal_rng.h"
  15          #include "hal_flash.h"
  16          #include <stdint.h>
  17          #include <stdbool.h>
  18          #include <string.h>
  19          
  20          // ======================================= Type definition
  21          #define TRANSISTOR            P10
  22          #define LED_1                 P11
  23          #define LED_2                 P13
  24          #define BTN_ALARM             P03
  25          #define BTN_SEAT              P01
  26          
  27          #define VADDR_VCU_ID          HAL_DATA_NV_BASE_ADDRESS
  28          #define VADDR_AES_KEY         (VADDR_VCU_ID + sizeof(uint32_t))
  29          
  30          #define DATA_LENGTH           16
  31          #define ADDR_LENGTH           5
  32          #define DATA_PAIR_LENGTH     (DATA_LENGTH + ADDR_LENGTH)
  33          
  34          typedef enum {
  35            KLESS_CMD_PING  = 0,
  36            KLESS_CMD_ALARM = 1,
  37            KLESS_CMD_SEAT  = 2
  38          } KLESS_CMD;
  39          
  40          // ======================================= Global variable
  41          static bool volatile radio_busy, received;
  42          static uint8_t tx_address[ADDR_LENGTH] = {0x00, 0x00, 0x00, 0x00, 0xCD};
  43          static uint8_t rx_address[ADDR_LENGTH] = {0x00, 0x00, 0x00, 0x00, 0xAB};
  44          static uint8_t xdata payload[DATA_PAIR_LENGTH];
  45          static uint8_t xdata payload_enc[DATA_LENGTH];
  46          static uint32_t idata AES_Key[4];
  47          static const uint8_t idata commands[3][8] = {
  48            { 0x5e, 0x6c, 0xa7, 0x74, 0xfd, 0xe3, 0xdf, 0xbc },
  49            { 0xf7, 0xda, 0x4a, 0x4f, 0x65, 0x2d, 0x6e, 0xf0 },
  50            { 0xff, 0xa6, 0xe6, 0x5a, 0x84, 0x82, 0x66, 0x4f }
  51          };
  52          
  53          // ======================================= Function prototype 
C51 COMPILER V9.60.0.0   MAIN                                                              01/13/2021 10:50:29 PAGE 2   

  54          void pin_init(void);
  55          void rtc_init(void);
  56          void clock_and_irq_init(void);
  57          void nrf_init(void);
  58          void sleep_mode(void);
  59          void make_random_number(uint8_t *p);
  60          void make_command(KLESS_CMD *cmd, hal_nrf_output_power_t *pwr);
  61          void make_payload(uint8_t *payload, uint8_t cmd);
  62          void send_payload(uint8_t *payload, uint8_t pwr, uint8_t retry);
  63          void set_pairing_mode(void);
  64          void receive_pairing(void);
  65          void update_configuration(uint8_t *success);
  66          void wait_button_released(void);
  67          bool receive_ping(uint8_t timeout);
  68          void set_normal_mode(void);
  69          void save_flash(void);
  70          void load_flash(void);
  71          
  72          // ======================================= Main function 
  73          void main(void){
  74   1        // local variable
  75   1        uint8_t pairing_success;
  76   1        KLESS_CMD command;
  77   1        hal_nrf_output_power_t power;
  78   1        
  79   1        // Initialise GPIO
  80   1        pin_init();
  81   1        // Initialise RTC
  82   1        rtc_init();
  83   1        // Initialise clock & irq
  84   1        clock_and_irq_init();
  85   1        
  86   1        // Load Flash
  87   1        load_flash();
  88   1        
  89   1        // Initialise RF module
  90   1        nrf_init();
  91   1        // Initialise watchdog
  92   1        hal_wdog_init(0x0300);
  93   1      
  94   1        while(1)  {           
  95   2          if(BTN_ALARM || BTN_SEAT){
  96   3            // handle bounce effect
  97   3            delay_ms(100);
  98   3              
  99   3            if(BTN_ALARM && BTN_SEAT){
 100   4              // Pairing Mode
 101   4              pairing_success = 0;
 102   4              
 103   4              // Set to pairing configuration
 104   4              set_pairing_mode();
 105   4              // Receive mode
 106   4              receive_pairing();
 107   4              // Check Payload
 108   4              update_configuration(&pairing_success);
 109   4              // indicator result
 110   4              if(pairing_success){
 111   5                LED_1 = 0;
 112   5                LED_2 = 0;
 113   5              } else {
 114   5                LED_1 = 1;
 115   5                LED_2 = 1;
C51 COMPILER V9.60.0.0   MAIN                                                              01/13/2021 10:50:29 PAGE 3   

 116   5              }
 117   4              
 118   4              set_normal_mode();
 119   4              
 120   4            // Wait until button released
 121   4            wait_button_released();
 122   4              
 123   4            } else if(BTN_ALARM){
 124   4              // Button Command Mode        
 125   4              command = KLESS_CMD_ALARM;
 126   4              power = HAL_NRF_0DBM;
 127   4              // Generate Random Number
 128   4              //make_random_number(&payload[DATA_LENGTH/2]);
 129   4              // Insert command to payload
 130   4              make_payload(payload, command);
 131   4              // Encrypt payload
 132   4              hal_aes_crypt(payload_enc, payload);
 133   4              // Send the payload
 134   4              send_payload(payload_enc, power, 1);    
 135   4              // indicator
 136   4              LED_2 = !LED_2;
 137   4            }
 138   3          } 
 139   2          
 140   2            // Normal Mode
 141   2            if (receive_ping(10) && !BTN_ALARM){
 142   3              // Generate Command       
 143   3              make_command(&command, &power);
 144   3              
 145   3              // Insert command to payload
 146   3              make_payload(payload, command);
 147   3              // Encrypt payload
 148   3              hal_aes_crypt(payload_enc, payload);
 149   3              // Send the payload
 150   3              send_payload(payload_enc, power, 1);
 151   3              
 152   3              // indicator
 153   3              LED_1 = !LED_1;
 154   3            }
 155   2      
 156   2          // reset wdog
 157   2          hal_wdog_restart(); 
 158   2          
 159   2          // Enter sleep mode
 160   2          sleep_mode();
 161   2        };
 162   1      }
 163          
 164          // ======================================= Function declaration
 165          void wait_button_released(void){
 166   1          while(BTN_ALARM || BTN_SEAT){
 167   2            hal_wdog_restart();
 168   2            delay_ms(50);
 169   2          }
 170   1          //delay_ms(100);  
 171   1      }
 172          
 173          void load_flash(void){
 174   1        uint8_t vcu_id[4];
 175   1        
 176   1        hal_flash_bytes_read(VADDR_VCU_ID, vcu_id, sizeof(uint32_t));
 177   1        hal_flash_bytes_read(VADDR_AES_KEY, (uint8_t*)AES_Key, DATA_LENGTH);
C51 COMPILER V9.60.0.0   MAIN                                                              01/13/2021 10:50:29 PAGE 4   

 178   1        
 179   1        // Apply address
 180   1        memcpy(tx_address, vcu_id, sizeof(uint32_t));
 181   1        memcpy(rx_address, vcu_id, sizeof(uint32_t));
 182   1        // Initialise AES
 183   1        hal_aes_setup(0, ECB, (uint8_t*)AES_Key, NULL);
 184   1      }
 185          
 186          void update_configuration(uint8_t *success){
 187   1        if(received && (payload[DATA_PAIR_LENGTH - 1] == 0xAB)) {
 188   2          //safe to flash
 189   2          save_flash();
 190   2          
 191   2          // Apply new aes key
 192   2          load_flash();
 193   2          
 194   2          //setting Tx address
 195   2          hal_nrf_set_address(HAL_NRF_TX, tx_address);
 196   2          //setting Rx address for pipe0
 197   2          hal_nrf_set_address(HAL_NRF_PIPE0, rx_address);
 198   2          
 199   2          *success = 1;
 200   2        } 
 201   1      }
 202          
 203          void save_flash(void){
 204   1        // Save to flash
 205   1        hal_flash_page_erase(HAL_DATA_NV_FLASH_PN0);
 206   1        hal_flash_bytes_write(VADDR_VCU_ID, &payload[DATA_LENGTH], sizeof(uint32_t));
 207   1        hal_flash_bytes_write(VADDR_AES_KEY, payload, DATA_LENGTH);
 208   1      }
 209          
 210          void receive_pairing(void){
 211   1        // Power up radio
 212   1        hal_nrf_set_power_mode(HAL_NRF_PWR_UP);
 213   1        // Configure radio as primary receiver 
 214   1        hal_nrf_set_operation_mode(HAL_NRF_PRX); 
 215   1        
 216   1        // Enable receiver
 217   1        CE_HIGH();
 218   1        received = false;
 219   1        while (!received && (BTN_ALARM && BTN_SEAT)){
 220   2          // Indicator
 221   2          LED_1 = !LED_1;
 222   2          LED_2 = !LED_1;
 223   2      
 224   2          hal_wdog_restart();
 225   2          delay_ms(100);
 226   2        }
 227   1        CE_LOW();
 228   1        
 229   1        // Power off radio  
 230   1        hal_nrf_set_power_mode(HAL_NRF_PWR_DOWN);
 231   1        //setting payload width back
 232   1        hal_nrf_set_rx_payload_width(HAL_NRF_PIPE0, DATA_LENGTH); 
 233   1      }
 234          
 235          bool receive_ping(uint8_t timeout){
 236   1        uint32_t ms = 0;
 237   1        // Power up radio
 238   1        hal_nrf_set_power_mode(HAL_NRF_PWR_UP);
 239   1        // Configure radio as primary receiver 
C51 COMPILER V9.60.0.0   MAIN                                                              01/13/2021 10:50:29 PAGE 5   

 240   1        hal_nrf_set_operation_mode(HAL_NRF_PRX); 
 241   1        
 242   1        // Enable receiver
 243   1        CE_HIGH();
 244   1        received = false;
 245   1        while (!received && ms < timeout){
 246   2          // Indicator
 247   2      //    LED_1 = !LED_1;
 248   2      //    LED_2 = !LED_1;
 249   2      
 250   2          delay_ms(1);
 251   2          ms++;
 252   2        }
 253   1        CE_LOW();
 254   1        
 255   1        // Power off radio  
 256   1        hal_nrf_set_power_mode(HAL_NRF_PWR_DOWN);
 257   1        //setting payload width back
 258   1        hal_nrf_set_rx_payload_width(HAL_NRF_PIPE0, DATA_LENGTH); 
 259   1        
 260   1        return received;
 261   1      }
 262          
 263          void set_pairing_mode(void) {
 264   1        // Set paring address
 265   1        memset(tx_address, 0x00, sizeof(uint32_t));
 266   1        memset(rx_address, 0x00, sizeof(uint32_t));
 267   1        
 268   1        //setting Tx address
 269   1        hal_nrf_set_address(HAL_NRF_TX, tx_address);
 270   1        //setting Rx address for pipe0
 271   1        hal_nrf_set_address(HAL_NRF_PIPE0, rx_address);
 272   1        //setting payload width
 273   1        hal_nrf_set_rx_payload_width(HAL_NRF_PIPE0, DATA_PAIR_LENGTH);
 274   1      }
 275          
 276          void set_normal_mode(void) {
 277   1        //setting payload width
 278   1        hal_nrf_set_rx_payload_width(HAL_NRF_PIPE0, DATA_LENGTH);
 279   1      }
 280          
 281          void send_payload(uint8_t *payload, uint8_t pwr, uint8_t retry){
 282   1        // Write payload to radio TX FIFO
 283   1        hal_nrf_write_tx_payload(payload, DATA_LENGTH);
 284   1        // Setting power output
 285   1        hal_nrf_set_output_power(pwr);
 286   1        // Set transistor based on Command
 287   1        TRANSISTOR = (pwr != HAL_NRF_0DBM);
 288   1        // Power up radio
 289   1        hal_nrf_set_power_mode(HAL_NRF_PWR_UP);
 290   1        // Configure radio as primary receiver (PTX)
 291   1        hal_nrf_set_operation_mode(HAL_NRF_PTX);
 292   1        
 293   1        while(retry--){// Start transmission
 294   2          CE_HIGH();
 295   2          radio_busy = true;
 296   2          while (radio_busy){}
 297   2          CE_LOW();
 298   2        }
 299   1          
 300   1        // Power off radio  
 301   1        hal_nrf_set_power_mode(HAL_NRF_PWR_DOWN);
C51 COMPILER V9.60.0.0   MAIN                                                              01/13/2021 10:50:29 PAGE 6   

 302   1        // Set transistor to Open
 303   1        TRANSISTOR = 1; 
 304   1      }
 305          
 306          void make_payload(uint8_t *payload, uint8_t cmd){ 
 307   1        memcpy(payload, &commands[cmd], 8);
 308   1        //memcpy(payload+8, &commands[cmd], 8);
 309   1      }
 310          
 311          void make_command(KLESS_CMD *cmd, hal_nrf_output_power_t *pwr){   
 312   1        // handle each buttons
 313   1        *pwr = HAL_NRF_18DBM;
 314   1        if(BTN_SEAT)  {
 315   2          *cmd = KLESS_CMD_SEAT;
 316   2        } else  {
 317   2          *cmd = KLESS_CMD_PING;
 318   2        }   
 319   1      }
 320          
 321          void make_random_number(uint8_t *p){
 322   1        uint8_t len = (DATA_LENGTH/2);
 323   1        
 324   1        // start
 325   1        hal_rng_power_up(1);
 326   1        while(len--){
 327   2          while(!hal_rng_data_ready()){};
 328   2          *(p++) = hal_rng_read();
 329   2        }
 330   1        hal_rng_power_up(0);
 331   1      }
 332          
 333          void pin_init(void){
 334   1        char i;
 335   1        
 336   1        // Disconnect unused GPIOs to avoid them floating in sleep
 337   1        for (i = 0; i < 8; i++){
 338   2            P0CON = 0x70 + i;
 339   2            P1CON = 0x70 + i;
 340   2        } 
 341   1        P0DIR = 0x0B; 
 342   1        P1DIR = 0x00;
 343   1      
 344   1        P1CON = 0x00 + 3; // Set P1.3 as outputb  again
 345   1        P1CON = 0x00 + 0; // Set P1.1 as output again
 346   1        P0CON = 0x10 + 1; // Set P0.1 as input again
 347   1        P0CON = 0x10 + 3; // Set P0.3 as input again
 348   1          
 349   1        P0 = 0x00;
 350   1        P1 = 0x00;
 351   1        
 352   1        WUOPC0 = 0x0B;  //set pin P0.3 & P0.1 as wake-up pin
 353   1        OPMCON = 0x00;  //latch open and wake-up pin active high
 354   1        
 355   1        // Set default 
 356   1        TRANSISTOR = 1;
 357   1        LED_1 = 0;
 358   1        LED_2 = 0;
 359   1      }
 360          
 361          void nrf_init(void){
 362   1        // Setting datarate
 363   1        hal_nrf_set_datarate(HAL_NRF_1MBPS);
C51 COMPILER V9.60.0.0   MAIN                                                              01/13/2021 10:50:29 PAGE 7   

 364   1        //setting crc
 365   1        hal_nrf_set_crc_mode(HAL_NRF_CRC_8BIT);
 366   1        //setting address
 367   1        hal_nrf_set_address_width(HAL_NRF_AW_5BYTES);
 368   1        //setting auto retransmitt
 369   1        hal_nrf_set_auto_retr(0x0F,0x0F);
 370   1        //settinf RF channel
 371   1        hal_nrf_set_rf_channel(110);
 372   1        //setting Tx address
 373   1        hal_nrf_set_address(HAL_NRF_TX, tx_address);
 374   1        //setting payload width
 375   1        hal_nrf_set_rx_payload_width(HAL_NRF_PIPE0, DATA_LENGTH);
 376   1        //open pipe
 377   1        hal_nrf_open_pipe(HAL_NRF_PIPE0, 1);
 378   1        //setting Rx address for pipe0
 379   1        hal_nrf_set_address(HAL_NRF_PIPE0, rx_address);
 380   1        //setting interupt mode
 381   1        hal_nrf_set_irq_mode(HAL_NRF_MAX_RT,1);
 382   1        hal_nrf_set_irq_mode(HAL_NRF_TX_DS,1);
 383   1        hal_nrf_set_irq_mode(HAL_NRF_RX_DR,1);
 384   1        //disable ack
 385   1        hal_nrf_enable_ack_payload(1);
 386   1        //clear interupt flag
 387   1        hal_nrf_clear_irq_flag(HAL_NRF_MAX_RT);
 388   1        hal_nrf_clear_irq_flag(HAL_NRF_TX_DS);
 389   1        hal_nrf_clear_irq_flag(HAL_NRF_RX_DR);
 390   1      }
 391          
 392          void rtc_init(void){
 393   1        hal_rtc_start(false);
 394   1        hal_clklf_set_source(HAL_CLKLF_RCOSC32K);
 395   1        hal_rtc_set_compare_mode(HAL_RTC_COMPARE_MODE_0);
 396   1        hal_rtc_set_compare_value(0xFFFF/2);
 397   1        hal_rtc_start(true);
 398   1      
 399   1        // Wait for the 32kHz to startup (change phase)
 400   1        while((CLKLFCTRL&0x80)==0x80);
 401   1        while((CLKLFCTRL&0x80)!=0x80);
 402   1        
 403   1        // Setting wake-up from TICK and IRQ
 404   1        IEN1 = 0x20|0x08; 
 405   1      }
 406          
 407          void clock_and_irq_init(void){
 408   1        // Wait until 16 MHz crystal oscillator is running
 409   1        #ifdef MCU_NRF24LE1
 410   1        while(hal_clk_get_16m_source() != HAL_CLK_XOSC16M){}
 411   1        #endif
 412   1        // Enable the radio clock
 413   1        RFCKEN = 1U;
 414   1        // Enable RF irq
 415   1        RF = 1U;
 416   1        // Enable global irq
 417   1        EA = 1U;
 418   1      }
 419          
 420          void sleep_mode(void){
 421   1        // Register retention mode
 422   1        PWRDWN = 0x04;
 423   1        // Standby mode (wait for irq)
 424   1        PWRDWN = 0x07;
 425   1        // Clear PWRDWN
C51 COMPILER V9.60.0.0   MAIN                                                              01/13/2021 10:50:29 PAGE 8   

 426   1        PWRDWN = 0x00;
 427   1        // Exit sleep mode
 428   1      }
 429          
 430          // ======================================= Interrupt Service Routine
 431          // RTC wakeup by tick
 432          void wakeup_tick() interrupt INTERRUPT_TICK {
 433   1         //LED_2 = !LED_2; 
 434   1      }
 435          
 436          // RTC wakeup by button
 437          void wakeup_irq() interrupt INTERRUPT_WUOPIRQ {
 438   1        // LED_1 = !LED_1;
 439   1      }
 440          
 441          
 442          // Radio irq
 443          NRF_ISR() {
 444   1        uint8_t irq_flags;
 445   1      
 446   1        // Read and clear IRQ flags from radio
 447   1        irq_flags = hal_nrf_get_clear_irq_flags();
 448   1       
 449   1        switch(irq_flags)
 450   1        {
 451   2          // Transmission success
 452   2          case (1 << (uint8_t)HAL_NRF_TX_DS):
 453   2            radio_busy = false;
 454   2            // Data has been sent
 455   2            break;
 456   2          
 457   2          // Transmission failed (maximum re-transmits)
 458   2          case (1 << (uint8_t)HAL_NRF_MAX_RT):
 459   2            // When a MAX_RT interrupt occurs the TX payload will not be removed from the TX FIFO.
 460   2            // If the packet is to be discarded this must be done manually by flushing the TX FIFO.
 461   2            // Alternatively, CE_PULSE() can be called re-starting transmission of the payload.
 462   2            // (Will only be possible after the radio irq flags are cleared)
 463   2            hal_nrf_flush_tx();
 464   2            radio_busy = false;
 465   2            break;
 466   2          
 467   2          // Received success
 468   2          case (1 << (uint8_t)HAL_NRF_RX_DR):
 469   2            // Read payload
 470   2            while(!hal_nrf_rx_fifo_empty()){
 471   3              hal_nrf_read_rx_payload(payload);
 472   3            }
 473   2            received = true;
 474   2            break;
 475   2            
 476   2          default:
 477   2            break;
 478   2        }
 479   1        
 480   1      }
 481          /** @} */
 482          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1168    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.60.0.0   MAIN                                                              01/13/2021 10:50:29 PAGE 9   

   XDATA SIZE       =     37    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12      32
   IDATA SIZE       =     40    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
